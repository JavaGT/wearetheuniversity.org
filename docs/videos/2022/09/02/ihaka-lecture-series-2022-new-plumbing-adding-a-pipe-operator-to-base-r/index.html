<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>We Are The University</title><link rel="stylesheet" href="/styles.css"></head><body><header><h1 style="color: #fff;font-family: 'Arial Black', Gadget, sans-serif;font-style: italic;font-weight: 900;text-transform: uppercase;">We Are The University    </h1><nav><ul><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/contact">Contact</a></li><li><a href="/blog">Blog</a></li><li><a href="/videos">Videos</a></li><li><a href="/authors">Authors</a></li></ul></nav></header><main><h2 style="text-align: center;">Ihaka Lecture Series 2022 | New plumbing: Adding a pipe operator to base R [1:11:05]</h2><p style="text-align: center;"><a href="https://www.youtube.com/watch?v=IMpXB30MP48" target="_blank">Watch on Youtube</a></p><p style="text-align: center;"><a href="https://www.youtube.com/channel/UCUKg41qkUTUQXGDzklgpmlQ" target="_blank">University of Auckland | Waipapa Taumata Rau</a></p><img src="https://i.ytimg.com/vi/IMpXB30MP48/maxresdefault.jpg" alt="Thumbnail for video titled: Ihaka Lecture Series 2022 | New plumbing: Adding a pipe operator to base R" style="width: 100%;"><div class="tags"><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#The University of Auckland</span><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#University of Auckland</span><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#UOA</span><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#Auckland University</span><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#Auckland</span><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#New Zealand</span><span style="background: #0003; border-radius: 0.3em; padding: 0.3em; display: inline-block; margin: 0.2em; font-size: 0.8em">#University</span></div><h2>Description</h2><p>Professor Luke Tierney, Ralph E. Wareham Professor of Mathematical Sciences, University of Iowa<br>4 August 2022</p><h2>Transcript</h2><p style="opacity: 0.9; font-size: 0.8em">Transcripts may be automatically generated and may not be 100% accurate.</p><p>hello<br>hi welcome to the second of the ihaka<br>lecture series for this year<br>tonight we're very lucky to have Luke<br>Turney as the speaker<br>um Luke<br>um Luke's a professor at the University<br>of Iowa<br>um which I don't know if you've thought<br>about this but this is a very brutal<br>early hour of the morning for him to be<br>we're lucky to have had Luke here a<br>number of times to visit<br>including quite an Extended Stay that he<br>had here<br>my first encounter with Luke's work was<br>actually about 1988 or 1989 I think<br>with the first software that I remember<br>him releasing which I think was called<br>eye views<br>which was an interactive Graphics<br>component that could be accessed I think<br>um<br>since then of course Luke has gone on<br>and is very well known for X lisp Stat<br>or lisp stat as it became<br>um which was a very important work and<br>showed the benefits of combining a<br>Computing language with interactive<br>graphics and showing the sorts of things<br>you could do as a result of that<br>not just a computer language system but<br>as well as work on his own project Luke<br>has been a very significant contributor<br>to R for a a long long time he was one<br>of the very first people that we had<br>join up to work on our<br>um in the old old days we used to<br>maintain a mailing list for anyone who<br>was interested in R and I can remember<br>we got quite excited when we got more<br>than 10 people who were interested in<br>our<br>and I can remember Robert coming in one<br>morning very excited saying you should<br>see who signed up on the mailing list<br>last night<br>and that was Luke and it was very much a<br>matter of fishing for minnows and<br>um Luke's been a very significant<br>contributor to uh for a long time<br>and a lot of people probably aren't<br>aware of how important his work has been<br>to the things that they do every day<br>when they work with our<br>the first thing I remember him working<br>on was the memory management and garbage<br>collection system<br>which replaced the sort of half-assed<br>amort of thing that I had implemented<br>initially and still stands there as a<br>very secure foundation for an awful lot<br>of computation<br>he since added the idea of reference<br>counting to that to avoid copying that's<br>going on<br>he implemented the namespace control<br>system<br>which is very useful for organizing<br>larger Computing systems so things like<br>packages and so on<br>and finally the most<br>interesting thing probably is the<br>bytecode compiler given that R is a very<br>compiler hostile system<br>it's important to have a compiler like<br>that working and providing speed ups for<br>an awful lot of code<br>all of these things make are a much more<br>pleasant and useful experience than it<br>would have been otherwise<br>so thank you Luke for that<br>tonight Luke's going to be speaking on<br>implementation of a pipe operator in r<br>and it's always interesting to see what<br>he has to say<br>well thank you very much that's uh<br>it's it's a great honor to be able to<br>speak in this section and and it's<br>really wonderful to have you as the<br>chair and thank you for that<br>introduction<br>not sure about the whale part um well<br>never mind um I wish I was in the um<br>in Auckland that's one of my favorite<br>places in the world<br>and it wouldn't be 1 30 in the morning<br>of course<br>um but here we are so<br>um<br>pipe operators in our<br>um start out with of course R is a<br>language for working with data and when<br>you work with data you typically have to<br>go through steps like data import<br>cleaning the data<br>um<br>reshaping and transforming and things of<br>that sort visualization<br>repeat<br>um<br>the forward pipe operator is something<br>that helps organize this kind of a<br>workflow helps connect up up<br>um<br>the most common form that's been used in<br>our foreign prominent in R for a number<br>of years is the magritter pipe which has<br>this percent greater percent notation I<br>was introduced around 2014.<br>um<br>recently<br>um several of the current hardcore and<br>several tiny Rich team members and<br>others worked on putting a somewhat<br>simplified but still very effective<br>version of a forward pipe operator into<br>base R and this the first version came<br>out with<br>uh 4.1 in last year<br>um and this was some Evolution with a<br>4.2 release this year and there's a few<br>more things in in the works maybe one<br>smallish thing for it for the next<br>probably for the next few weeks<br>um so I'm going to talk a little bit<br>about<br>um Ford pipe operators and R and other<br>languages why they're they're useful and<br>some of the thinking behind why it made<br>sense to put one into base R and do it<br>in the particular way that we did<br>so why are pipes useful<br>um<br>the basic idea of what this forward type<br>operator does is provide an alternative<br>to nested function calls<br>um<br>simple example of a nested function call<br>is something like this you plug X into F<br>that result goes to G the result then<br>goes on to H<br>um<br>many find thinking about and reasoning<br>about this and thinking about whether I<br>compute first second and so on a bit<br>more confusing than it ideally should be<br>because<br>the computation is you do the F<br>computation then the G computation then<br>the H computation but the order in which<br>it shows up and the code is is the other<br>way around<br>um put it another way if you read<br>something like this you kind of have to<br>read it and write it from the inside out<br>if you're if you're going to debug each<br>step it's you write the f of x check<br>that then you go back and Surround it<br>with a G and so on<br>it gets harder if you have to pass on<br>additional arguments<br>um that basically modify what F does and<br>what G does and so on<br>and that's pretty much always necessary<br>in in<br>our code except for very trivial<br>situations<br>um<br>but here's an example of a of a piece of<br>code where I'm using the some functions<br>from the dpliar package on the New York<br>City flights data<br>um<br>for 2013 and picking out the the flights<br>that go from New York City to Chicago's<br>O'Hare Airport and Computing the the<br>monthly average delay<br>so this is a nested<br>um call version of it<br>okay but<br>when you start reading it the first step<br>is you pick out the flights that go to<br>O'Hare then the next step is you apply a<br>grouping operation to identify the<br>different months these flights belong to<br>um<br>finally you do the summarization so I<br>worked my way out<br>uh to the the final step and the the<br>modifier Arguments for the summarization<br>or actually the things that I'm<br>Computing are separated from what I'm<br>doing by the intermediate processing of<br>the data<br>um so reading it is inside out<br>developing is kind of inside out as well<br>so with a forward pipe operator does if<br>it takes an expression like this and<br>lets you write it<br>and I'm using the notation of the base<br>pipe as we have it have it now in R<br>um you you can write this like this<br>so X gets passed into F the result gets<br>passed into G it's passed into H it's<br>kind of the way the computation happens<br>and it's the way you often want to think<br>about it<br>um<br>if you want to think about what's<br>happening or a way of thinking about<br>happening is you take the first bit and<br>the X goes into f is implicitly<br>translated<br>by taking the left hand side result<br>and putting it in as the first argument<br>uh to the F so basically this bit is<br>just transformed to an f of x and if we<br>do that in the pipeline we take the<br>original version that has three steps to<br>it and the first one's taken care of by<br>forming the f of x now we do the same<br>thing again<br>and the next step that the f of x result<br>into the G and the<br>um finally the the uh the last step<br>moves the G of f in into H that's what<br>happens in the evaluation process<br>um<br>and you can think of that as basically a<br>translation of the pipe from this form<br>if I want to look at the that simple<br>flights to Chicago example<br>um this is what it would look like done<br>with with a pipe um<br>there's the filter step<br>followed by the grouping step and you<br>can see them argument that modifies<br>exactly what are we grouping on and then<br>the summarization where the things we're<br>calculating are right there even with a<br>summary so things are grouped together<br>and it's a nice linear uh form like that<br>um<br>so forward pipe operators allow you to<br>express operations in the order in which<br>they're carried out rather than that<br>nested form and the additional arguments<br>appear together with the operations<br>it's very natural to write this kind of<br>thing if you're<br>keep bugging this in stages you would<br>start with just the first bit I would at<br>least<br>check it out<br>in my idd IDE just recall that<br>previous expression add a next pipe<br>stage to it do it again and that works<br>well for me to write the code is also if<br>I'm doing this in class showing students<br>how to do it it's a nice nice flow much<br>nicer than having to write the Second<br>Step around the first step and then the<br>third step around the second step<br>there are other ways of reducing the the<br>nesting one is to use temporary<br>variables so if we did that in this<br>example<br>we'd start with again computing<br>the uh filtering the flights down to the<br>ones going to to Chicago<br>um then we<br>take that temporary result and group it<br>to get a new temporary result then we'd<br>apply the summarization<br>um it works<br>um but this is a lot noisier there's a<br>lot more stuff that's kind of extraneous<br>with those variable names<br>um in this case I just picked TMP<br>um I wanted to pick something meaningful<br>good variable leaves are hard to come by<br>which is why I use x and TNT so much you<br>can use a temporary like this but<br>inevitably I'll end up having oh yeah I<br>want to keep that one and then I stomp<br>on it other people may be better at it<br>so it works but it's not ideal<br>um<br>this is something that you can see in<br>our code but it's something that people<br>come come across in in many functional<br>function oriented mostly functional<br>languages that yes in principle<br>you can use nested calls for all sorts<br>of things but if you actually want to<br>get things done it's nice to have a pipe<br>operator<br>um and uh so the basic idea that that<br>goes across languages is you've got a<br>left-hand side computation<br>an operator that says feed that forward<br>pass it Forward into<br>side computation that uses the result<br>the details will vary from language to<br>language<br>first language that introduced this idea<br>seems to have been a dialect of the ml<br>language a functional language called<br>Isabel ml in the mid 90s<br>but many languages have followed F sharp<br>which is a functional language for use<br>in The NET Framework<br>supports a pipe operator Julia does<br>Elixir is another language<br>JavaScript and typescript have been<br>working on incorporating one for a<br>couple of years I'm not actually quite<br>sure where they are on it but the the<br>discussion which is linked uh here<br>um if these slides are made available<br>um<br>is is kind of interesting and it and it<br>seems to be typical of a lot of<br>languages and that they're sort of very<br>strong purists since seem to think that<br>well there's nothing wrong with nested<br>calls but people who want to get work<br>done really prefer having the option of<br>having a type operator available even if<br>it isn't the most pure uh<br>in terms of implementing this idea there<br>seemed to be more or less two approaches<br>and across the languages<br>um the conceptually simplest one is that<br>the right hand side<br>is an expression that produces a<br>function of one argument a unary<br>function and all the pipe expression<br>means is<br>compute the left hand side value and<br>pass it to the right hand side function<br>that's basically what Julia does what F<br>sharp does<br>the other approach treats the<br>um right hand side as an expression<br>takes the left hand side and inserts it<br>into that expression and then evaluates<br>the result<br>um that's what the r pipes uh do and<br>that's what the Elixir language for<br>example does so the first approach is<br>really quite simple<br>but<br>it's really in its pure form Deals Only<br>with functions that take a single<br>argument so if you are we always need<br>these additional arguments like in the<br>flights example<br>um<br>if you want to handle that you either<br>need to do something like create an<br>anonymous function that puts in those<br>additional arguments or have some kind<br>of language level support that addresses<br>this<br>um<br>if you're using Anonymous functions it<br>actually can also lead to some syntactic<br>surprises I'll mention one a little a<br>little later<br>so<br>the the second approach which is just<br>you think of as a substitution you take<br>the right hand the right hand side and<br>insert the left hand side and then<br>evaluate<br>you need some mechanism or convention<br>for where do you put the<br>left hand side result<br>there's implicit conventions<br>like what's used in most cases in the<br>magritter pipe and the um the new base<br>plate is to<br>put the left hand side as the first<br>argument of the function followed by<br>whatever other arguments there might be<br>listed explicitly so it's an implicit<br>first argument approach some languages<br>do it last argument<br>the other option is an explicit<br>designation using a placeholder<br>uses a dot but it's optional in some<br>cases underscore is used by a number of<br>languages percent sign is in is used by<br>a number<br>um<br>the the Alexia language one reason I<br>mentioned it is is that it does what the<br>magritter pipe does implicitly moving<br>putting the left hand side result in as<br>the first argument of the function<br>implicitly<br>um as the base pipes do<br>um<br>you should mention Unix pipes the<br>uses the word pipe<br>um<br>people sometimes<br>superficially say that well the pipe in<br>the car is like<br>there's a superficial similarity and of<br>course Unix pipes have been along for<br>around for much longer than these these<br>functional language forward pipe<br>operators but they're really it's really<br>a different kind of animal<br>um the the Unix pipe you have a process<br>you pipe this result into another<br>process<br>um<br>the left hand side processes output<br>stream is connected to the input stream<br>of the right hand side process and it's<br>a stream processing idea the two<br>processes the producer and the consumer<br>can be running concurrently the<br>consuming right hand side starts reading<br>data as soon as anything's available the<br>left hand side can keep producing more<br>data and it gets picked up when it's<br>when when the right hand side is ready<br>um you know the left hand side<br>potentially can be generating an<br>infinite stream of data on the right<br>hand side just picks up what it wants<br>until it's done and then stops so it's<br>okay<br>um that's a bit of General background<br>um now in terms of r<br>there's a pretty nice blog post that<br>Adolfo Alvarez posted<br>four or five years ago originally but<br>updated last year on the evolution of<br>pipes in R and<br>according to that post the starting<br>point that you can identify for the idea<br>is a post<br>um<br>by an anonymous user in in stack<br>overflow<br>asking about whether the F sharp pipe<br>which is one of the simple one<br>single right hand side produces a single<br>argument function uh idea pipes that um<br>it's so it's a simpler implementation<br>can you make that happen in a r and um<br>same day Ben Bulger replied with a<br>simple solution that you can make<br>simpler still and and write just like<br>this so I I picked a slightly similar<br>notation here<br>um with with a percent operator it's a<br>function two arguments a left-hand side<br>value and a right hand side function and<br>all it does is apply the function to the<br>value<br>that's conceptually all that's involved<br>it works fine for single argument<br>functions here I'm just taking the log<br>and then exponentiating again<br>um<br>now again<br>we almost always want in in things like<br>the flights example to be using<br>additional arguments<br>F sharp and a number of other<br>functional languages that that use this<br>approach<br>support and idea of partial application<br>um so basically if you if you pass only<br>one argument to a function that can take<br>two that produces a new function taking<br>only that additional argument and that<br>leads to you don't need anything else to<br>be able to handle multiple arguments<br>um we don't have that in R and it's it's<br>just sufficiently different from kinds<br>of things you could do with r it's not<br>realistic you can think about adding it<br>so the option in R really is to create<br>if you forced to use single argument<br>functions on the right hand side<br>the only real option is to work with<br>so<br>um<br>again taking that flights data example<br>you can write a function of one argument<br>that does the filtering with the<br>incoming data same thing with the<br>grouping same thing with the<br>summarization<br>um<br>it's pretty noisy uh<br>and as syntax the the<br>even without the written highlighting<br>that function takes up a lot of visual<br>space a lot of attention away from the<br>part that's really going on<br>you can use the recently introduced<br>shorthand<br>and one reason that was introduced was<br>to reduce the noise level but it's still<br>a number of variations more<br>sophisticated variations on a pipe were<br>proposed over the next couple of years<br>but the and if you want more detail look<br>at the the blog post that I uh that I<br>linked to<br>um<br>than a gritter pipe<br>um is the one that really<br>caught on<br>and<br>um<br>has now become quite widely widely used<br>the earliest version is to have readings<br>correctly<br>required a an explicit placeholder a DOT<br>um so with that version you would write<br>the flights example like this the<br>first step in the flights argument is<br>passed as the first argument via the dot<br>Second Step the result of the filter is<br>passed via the dot to the grouping and<br>and so on<br>um<br>fairly quickly the decision was made to<br>meet that that optional if it's in the<br>first position so we're now using an<br>implicit passing of the first argument<br>um this works very well<br>for what some people come to call pipe<br>friendly functions ones that take<br>operate on data frames but take the data<br>frame as their first argument pretty<br>much all the tiny versus designed that<br>way<br>there are a good number of Base R<br>functions designed that way as well but<br>there are many that aren't<br>maybe LM is the prime example you take<br>the linear model the first argument is a<br>okay so that's the background and so the<br>migrator pipe uh is is what had had<br>and it was it is very still very very<br>successful<br>um there are some issues<br>um Leonel Henry has a blog post in 2016<br>on a number of different things uh and<br>one section is on the pipe and the<br>Magruder pipe and<br>um<br>some of the things that he points out is<br>is that because of the processing that<br>happens at runtime stack traces when<br>there's an error are more complex than<br>they need to be we have a lot of pipe<br>Plumbing if you will in there this has<br>been cleaned up a little bit but it's<br>still more than than you would like<br>there's also because the processing of<br>the of the pipe happens at runtime some<br>computational overhead<br>it's not going to matter if the data<br>sets are reasonably large but if you<br>were to use pipes and small data sets in<br>a loop it would matter<br>um<br>another aspect is there that the<br>Magruder pipe has acquired a number of<br>fancier features<br>um that<br>are certainly useful in in some cases<br>but they add some complexity that if<br>you're describing the pipe you have to<br>make sure you document them and you're<br>maintaining it make sure you don't break<br>them<br>um<br>they're not used very much so simple<br>being able to have something that's a<br>little simpler to maintain was a uh was<br>a something to think about<br>um so the point we came to is that<br>the concept of a pipe is has become<br>pretty well established both in our and<br>other other languages of a full Wood<br>Pipe operator<br>um<br>and so the question was should we think<br>about taking this and thinking of it as<br>a core feature that should be available<br>in the base language that way it<br>wouldn't require an additional package<br>for someone who wants to to use it<br>um<br>and and that has some advantages<br>um and also provide an opportunity to<br>maybe clean up some of the issues and<br>and just simplify things a little bit by<br>just focusing on what has really turned<br>out to be<br>um the most useful features of it<br>um the idea of putting something in in<br>our was was probably first brought<br>forward by by several of the of the<br>tiger verse team<br>um Leonel Henry Jim Hester Hadley<br>Wickham<br>um<br>and what we have now<br>um<br>is basically a result of a collaboration<br>between the few lists in<br>the our Core group and those folks in<br>the titaniverse team in particular and<br>several other people in the our<br>community who contributed Duncan Murdock<br>in particular contributed quite a bit<br>quite a bit<br>um<br>so<br>let's look at what we have in 4.1 which<br>was released last year<br>um<br>started with the most common use pattern<br>for the magritter pipe is the implicit<br>first argument use<br>um<br>if you work with titaniverse<br>you can get away almost never using the<br>dot placeholder I've been teaching for a<br>couple years and I'm pretty sure I'm<br>tied it with Titan version I'm pretty<br>sure I don't use it anywhere in my notes<br>um<br>foreign<br>idea<br>um for a number of reasons<br>um<br>one of which is that in our the idea of<br>what is the first argument becomes a<br>little fuzzy since we can use named<br>arguments in various positions so when<br>is the first argument in an expression<br>in a call expression isn't necessarily<br>the first argument in the function<br>definition when you start putting named<br>but<br>nevertheless<br>um<br>if we want something that we put into<br>base to be<br>reasonably widely adapted and there's no<br>reason to do it if that's not the goal<br>it made sense to stick with what people<br>are familiar with from the Magruder<br>framework unless it was absolutely<br>necessary to go in a different direction<br>or there's really compelling arguments<br>so for that reason we stuck with the and<br>started with the<br>implicit first argument idea which I<br>showed in the earlier examples using of<br>the base pipe<br>um<br>when you're doing that implicit<br>substitution if you remember back to<br>when I sort of walked through what an X<br>goes into F goes into g equals into H or<br>X then G then F10 Gene and H in the<br>translation<br>you can think of<br>processing this just as a syntax<br>transformation that is in fact a<br>reasonable at least a possible way to<br>idea was was suggested first by uh<br>Lionel Henry and Jim Hester uh and these<br>are links to their<br>um<br>GitHub uh um<br>the wrinkles that that have<br>chain changes that that can be made to<br>the grammar to to make this this work<br>out<br>so this is the approach that we went<br>with in the um<br>so what this does is here<br>I've written the code that I showed<br>earlier the simple code<br>um X types into the F result pipes into<br>G pipes into h<br>as a string and if you parse that string<br>using the parse function<br>it just produces the nested call and so<br>um<br>there's no run time overhead because in<br>evaluating this because the pipe has<br>been transformed away<br>there's no additional runtime layers<br>that confuse tracebacks so error<br>handling and Reporting and Analysis is<br>is much simpler<br>um<br>this isn't the first time something has<br>been done this way uh the one other<br>example is the right assignment operator<br>if you write<br>compute something like the log of 2 and<br>the right arrow assigning it into a<br>variable X<br>and you look at what that how that is<br>parsed it turns out it's just turned at<br>parse time into a left an ordinary left<br>assignment it may be more convenient to<br>write it this way but it's translated<br>okay um<br>now as simple as the idea of<br>stick it in the first argument is<br>since everything in R is a function<br>including things like for Loops while<br>loops<br>bleed to some weirdness if if you aren't<br>a little bit<br>looking at the Magruder pipe which<br>doesn't guard against this thing this<br>this sort of thing if you were to pipe a<br>value into a for Loop<br>you get an error<br>but it's not particularly easily<br>understood error<br>um<br>nobody would be likely to want to do<br>that this is something you might<br>actually think about trying to think<br>about well what might this do piping<br>something into an anonymous function<br>um and you know for example in F sharp<br>or a Julia this kind of thing would work<br>um<br>again the the answer is a little bit the<br>the error is a little bit uh inscrutable<br>um it's the result of just okay function<br>is a function we'll just stick something<br>in and he produces something that makes<br>no sense<br>if I do the same sort of thing with a<br>with an if expression I don't get an<br>error it's the it's it does not<br>evaluating it produces a result it's not<br>a result that makes a whole lot of sense<br>um but um<br>there's no error film<br>now again except for maybe the function<br>thing that you might want to try<br>nobody is really likely to write this<br>sort of thing on purpose<br>but you've got a bigger code base you<br>accidentally delete or add a brace<br>parenthesis somewhere you can end up<br>with this embedded in your code you run<br>it and you get an error that you just<br>can't figure out because it's not really<br>pointing you in the right direction or<br>you get no error<br>just a result that makes no sense<br>so to be careful about this what we<br>decided to do with the base pipe parser<br>is to Signal an error<br>it basically only allow<br>standard functions on the right hand<br>side not syntactically special ones<br>so with these things all those all those<br>three examples you get an error that's<br>at least reasonably understandable<br>um you can't you do that on the right<br>hand side<br>for now because it's easy<br>we just ruled out all syntactically<br>special things there are some where it<br>might make sense to permit them uh in<br>particular the ones that the number of<br>folks have asked about and there were<br>probably makes<br>is the the extractor functions the<br>single and double square brackets and<br>the dollar and the outside<br>um<br>foreign<br>these are things if you use them you<br>have to use them with the back quote<br>and that<br>makes anything you do with them a little<br>less readable already so there may be<br>other other approaches and I'll talk<br>so<br>4.1 released last year included this and<br>only the in this this simple implicit<br>first argument uh based base pipe which<br>works<br>very well<br>all pipe friendly functions ones that<br>take their data frame argument as the<br>and<br>have these been working uh having<br>weekends been working on a second<br>edition of the art for data science book<br>and<br>is now converted that to use the base<br>pipe and the Tweety sent earlier this<br>year<br>we mentioned it it was surprisingly it's<br>easy to do the conversion it's the small<br>number of cases where something just<br>more the greater specific was used and<br>that wasn't really a big deal to work<br>around<br>um<br>that said there there are cases where<br>you do<br>need to pass data to an argument other<br>than the first and it'd be nice to be<br>able to do that in a more convenient way<br>than than using Anonymous functions<br>um again LM is a good example you can do<br>it with an anonymous function so<br>here's an example that I'll continue<br>with taking the old Mt cars data<br>pick out cars that have four cylinders<br>and then fit a linear model of miles per<br>gallon against displacement for that<br>data set<br>um<br>this works again it's visually noisy you<br>have in addition to the anonymous<br>function you need these parentheses<br>to make it work at least with it with<br>the current definition of the pipe<br>um<br>we did throughout the development for<br>our 4.1 try and come up with something<br>better but<br>eventually we just ran out of time<br>and we thought we had things in the new<br>testing showed and that I didn't act<br>there were issues with it<br>um<br>so we had to stop<br>and and just move on for that release<br>um<br>one to 4.1 was released April last year<br>we had a chance to go back and and look<br>at some of the things that we tried and<br>and<br>um<br>see if we can make them work a little<br>better<br>um<br>so uh let's look at what you can do with<br>McGregor McGregor supports the as a<br>placeholder<br>um so that little empty cars example can<br>be written in this form where the LM<br>call does not take the result of the<br>previous step through the implicit first<br>argument because that wouldn't work<br>instead it goes through the dot that is<br>is shown here with with the uh as the<br>data argument<br>that's fairly clean<br>um but there are some drawbacks<br>um<br>especially if you're working in<br>something like the Tidy verse where<br>you've got mostly pipe friendly<br>functions you've got maybe 10 steps and<br>one of them is not doing the implicit<br>first argument<br>um you want to be able to see that so<br>with the Magruder approach and that<br>placeholder the only way you can see it<br>is by spotting the dot which is the<br>smallest glyph you can possibly create<br>and for my eyesight at least it's not a<br>good design<br>um<br>so that's one one issue<br>there's also a bit of trickiness that<br>comes with the fact that<br>the way magritter works is possible to<br>use that thought<br>anywhere including within<br>but<br>the framework has to decide is it going<br>to basically support passing things<br>through the dot or is it going to<br>support putting so that only I should<br>say or is it going to support putting<br>that into<br>putting the implicit first argument in<br>and the way it signs it is looks at the<br>top level call<br>and if there's a dot in there then it<br>doesn't do the first argument so<br>insertion the implicit first argument<br>pass if there's no dot it does so<br>artificial little example<br>here if I type with my Grider one into C<br>of a DOT with that this thing any as a<br>single argument<br>that dot means don't do the implicit<br>first argument substitution and we get<br>just C of one<br>If instead of one I have something like<br>that plus one<br>instead of just that I have that plus<br>one<br>that that is not at top level<br>so when my gritter processes it it<br>substitutes the first it inserts the<br>first the the<br>basically inserts another dot that's the<br>first argument<br>so one<br>and then it does the computation of the<br>second argument<br>so<br>people have written code that takes<br>advantage of this to me at least that's<br>the kind of thing where you might feel<br>very pleased with yourself for an hour<br>or two and then three weeks later you're<br>being mad at the person who did this<br>after you spent an hour trying to figure<br>out what that code did<br>um<br>so I would like to avoid these kind of<br>issues a little bit<br>we tried a couple different things<br>um one approach that looked good<br>initially<br>was to<br>use an anonymous function<br>allow an anonymous function on the right<br>hand side like F sharp or Julia to do<br>um it's still a little wordy<br>um and Visually noisy<br>to handle that um<br>uh linear model this way but it does<br>have an advantage of calling attention<br>to the fact that this is not the simple<br>implicit first argument approach so you<br>see it you can't really miss it<br>um<br>problem is that<br>the way expressions are parsed and we're<br>fitting here a pipe operator into a<br>fairly Rich syntax that has things like<br>defining a function and all that in it<br>things are not parsed in the way that<br>you think they're going to partly parsed<br>when you're riding a pipe here's a<br>little example<br>um artificial but still suppose you<br>wrote a pipe that takes<br>one pipes it into a function that just<br>adds one to it and then assigns the<br>if you're thinking pipes that's probably<br>what you think this expression is<br>it's not what it means because the<br>function<br>binds more tightly than than the than<br>the pipe<br>and so what this really it's not exactly<br>the same but this is<br>essentially boils down to this<br>the assignment the right assignment is<br>part of the function body so you're<br>assigning a local variable in the<br>function so this is definitely not what<br>you're trying to do<br>and this allowing this was just too<br>risky<br>at the business<br>you do run into exactly this issue with<br>Julia now Julia doesn't as far as I know<br>at least have a left have a right<br>assignment<br>but if you have if you pipe through<br>three Anonymous functions with the Julia<br>pipe those functions that are actually<br>nested and that means that they're<br>variables that they see are are the ones<br>you know local variables from the outer<br>one the first one are seen by anybody of<br>the of the third one<br>it's a source of possible confusion<br>um<br>so<br>keeping in mind we wanted things to be<br>visible<br>um and and maybe be able to give a name<br>to the variable to to the value that<br>we're going to uh the left hand side<br>value that we're going to be using the<br>non-standard location next thing we<br>tried was<br>basically it's a special purpose<br>function notation that that parsed in<br>the right way so this particular is what<br>we implemented the the<br>left hand side can look like d which is<br>the variable<br>arrow and then the body<br>um we actually<br>had this implemented in 4.1 but not<br>enabled by default you could set an<br>environment variable to to use it<br>but the more we looked at it after the<br>release of 4.1 the more clear it became<br>that from a user point of view<br>this was just too much Syntax for<br>something very simple<br>um and maybe even more important<br>making this work in the parser involved<br>a lot of changes and the parser for our<br>it's already a pretty rich language<br>it was already complicated enough we<br>didn't want to go there and have to<br>maintain those extra changes just for<br>this purpose so we backed off and<br>after some experimenting what we ended<br>up with is a placeholder again<br>but we picked an underscore as something<br>that is<br>generally at least more visible than a<br>DOT<br>um<br>because of the fact that we're still<br>using a substitution approach we don't<br>want to allow it to be used more than<br>once<br>so it's only once they can be used<br>otherwise the left hand side would be<br>evaluated twice<br>and to avoid<br>those issues of using it in a<br>sub-expression like the the example I<br>showed with with the c function we only<br>explicitly only allow it in the top<br>level<br>um one additional requirement we put in<br>at least for now is that it has to be<br>used as a named argument<br>um so the empty cars example using the<br>underscore placeholder looks very much<br>like<br>the Magruder version we're using the<br>base pipe and then instead of the dot we<br>have the underscore which again for me<br>at least is more visible it's it's<br>natural to use it with<br>a named argument in this case you don't<br>have to do that with magrader you do<br>have to do it with a big spike<br>um<br>so<br>the underscore is more visible well that<br>depends on fonts some fonts make it very<br>thin but most fonts that I've worked<br>with is much more visible than the DOT<br>um<br>the requirement of a named argument also<br>helps with the visibility so again you<br>know 10 steps one of them is the<br>non-standard one it will stand out much<br>more than just a DOT<br>um<br>also<br>basically forces it to be a top level<br>argument and for most people it's easier<br>to think about requiring to be named and<br>is that top level<br>if you think about parse trees you can<br>yeah you can figure out that if it's<br>plus dot what that plus two is not top<br>level or and and and so<br>you could do this kind of thing in<br>current R<br>um and that means basically you can do<br>almost everything that people<br>do with with McGregor<br>um<br>so thinking of going forward what what<br>one of the things that's that's come up<br>um<br>in in discussions on our devel is<br>if you want it might be nice to switch<br>back to quickly to that example<br>um if at the end of this computation you<br>can put in a step that says pull out<br>just the coefficient Vector so do an<br>extraction step<br>um<br>how do you do that<br>um with the Magruder pipe you can just<br>add a stage that says using the dot<br>placeholder dollar co-f of course you<br>can also do this with back quotes in the<br>dollar and then rely on implicit<br>argument passing but to me this code is<br>unreadable and well not unreadable but<br>it's harder to read and the whole point<br>of pipes is to make things easier to<br>read so yes you can do this but this is<br>what I would this is what I would think<br>of as as the more natural way to do it<br>doesn't work currently in our 4.2 with a<br>base pipe because in this form we're not<br>using a named argument<br>uh using the underscore as a named<br>argument and of course with this syntax<br>there's no way of supplying the name the<br>name the variable is called X in the<br>documentation but there's no way of<br>doing x equals and then subset<br>um<br>so<br>a lot of the experimenting we've done on<br>this we've done in a branch in this the<br>N repository called our syntax so this<br>is a link to that uh that Branch again<br>if we could make the slides available<br>um uh you'll be able to look at it there<br>um<br>that Branch currently supports<br>um doing<br>exactly what I showed uh using an<br>underscore and then dollar and COV that<br>works<br>um So based<br>what we've made is an exception to the<br>rule of of having requiring a named<br>argument if it's the first argument to<br>if the underscore is the first argument<br>all right now<br>having pulled out the coefficient<br>Vector which is two components we might<br>want the next just pick only the<br>slope<br>so what would seem natural<br>to me is to be able to in the base pipe<br>use<br>to stick in the double square bracket<br>two to pick out that element or in the<br>Magruder case<br>um the same thing just using a DOT<br>instead of the<br>the underscore<br>this does not work at McGregor<br>um and you get again one of these<br>slightly inscrutable uh error messages<br>because of what what's happening under<br>the hood<br>you can of course pull out that second<br>component by using another pipe stage so<br>something like this so we pulled out the<br>coefficients by piping into dollar and<br>then we pull out the second element by<br>piping into double square bracket<br>this seems awkward<br>um what we did in the that syntax branch<br>is again to relax requirements a little<br>bit to allow this to work in the more<br>natural way<br>um so this is re relaxing the rule that<br>the underscore has to be a top level<br>argument it can be something other than<br>top level<br>if it is the head of an extraction chain<br>I think that's the simplest way of<br>describing this<br>um<br>and so you could have a underscore<br>dollar together component pick up the<br>third out second element here maybe<br>that's a list you could pick out<br>something else with a dollar and so on a<br>chain like that will will work<br>um<br>so that is what's supported now in that<br>experimental branch<br>I'm hoping to move that into our develop<br>in the next month ish and that hopefully<br>will give us a chance to uh to play<br>around with it and and see if there's<br>any<br>any gotchas in it<br>um<br>uh okay so that's that's what I'm<br>expecting hoping for uh for the next uh<br>next release uh let me started wrapping<br>up<br>um<br>R has a long history at this point and<br>the syntax itself goes back much further<br>to the to the S language<br>um<br>it does evolve we have added new<br>features<br>um to the language itself<br>um a lot of things you can add just to<br>the link and to the ecosystem just using<br>packages even operators using the<br>percent something percent uh idea<br>um that's almost always a good place to<br>start rather than this must go into base<br>and please do it for me kind of thing<br>um<br>a big Advantage for those of us who are<br>working on maintaining are and having<br>things be in package spaces we don't<br>have to deal with it and support it<br>somebody else is signed on to to<br>handling that<br>um<br>it does mean that if you want to use<br>such a feature you have to have a<br>dependency on some package and packages<br>do become stale maintainers move on and<br>things like that<br>um<br>so once something it's something is<br>reasonably small it becomes clear that<br>it is widely used is it worth at least<br>having a conversation about whether it's<br>something that should move into into<br>base uh doing that<br>use your greater stability and<br>availability<br>but of course a big cost is that<br>the base maintainers have to take over<br>maintenance<br>um and you know there aren't that many<br>of us and there's a lot to do<br>um<br>if you decide you need to syntax change<br>to make something happen that is for<br>something you cannot do in packages<br>um you can<br>make a fork or something but but<br>that that will have to be done by by<br>core developers and it has to be done<br>with a great deal of care<br>the syntax is quite Rich already<br>it is easy to have come up with an idea<br>that seems reasonable but turns out to<br>have some interactions you wouldn't<br>really think through like the bear uh<br>Anonymous function as the right hand<br>side issue that that that<br>um<br>it took a while to realize why that was<br>not such a good idea<br>um<br>so the forward pipe operator is<br>something that as a as a language<br>feature in languages in general is is<br>newer than the base R syntax really<br>um so if something's come along many<br>languages have decided to adopt it<br>um and<br>um it does seem like it was a reasonable<br>choice to do that uh to bring it into<br>the core of our as well<br>um the the experience with with McGregor<br>showed it was a good idea<br>having had that experience knew what was<br>widely used and what features or maybe<br>things we don't necessarily you can<br>still use them<br>and you can use both pipes these<br>prophets and confuse you but you can use<br>them together in one pipeline but<br>um it seemed reasonable to bring in the<br>core features<br>um<br>we did it fairly slowly fairly<br>cautiously and that turns out I think to<br>have been been the right thing<br>especially since we're working at the<br>syntax level<br>um<br>throughout the process<br>um when something got into base<br>um I think I usually sent an email<br>saying here's a change try it out uh<br>through the iron level mailing list<br>um<br>anytime you change based is going to be<br>especially syntax there's going to be in<br>some discussion you might call it robust<br>um some people there'd be some<br>contributions that are very well<br>informed and very good others well maybe<br>not quite so much<br>um<br>in in in this case uh even though the<br>discussion started and are developed in<br>most cases it often spilled over into<br>Twitter<br>um interestingly surprisingly to me some<br>of the most useful contributions<br>actually came through Twitter on this<br>discussion so it's been an interesting<br>Journey<br>um going going down here but overall I<br>think it was the right thing to do<br>to make this one change the base and um<br>anyone<br>you said one of the things that makes it<br>hard to change the language a little bit<br>is that the parser actually has to be<br>adapted and that the compiler needs to<br>take care of it is there any work being<br>done on changing the whole compiler<br>infrastructure to be more something like<br>llvm and like all the tools that are<br>um for the most part changing the parser<br>doesn't doesn't affect the compiler the<br>bytecode compiler as it is it works off<br>the parsed<br>um uh data<br>um so you change the surface syntax as<br>long as you're still parsing down to the<br>same harsh tree<br>um if you introduce a new basic<br>operation a new a new primitive and you<br>want<br>played the Primitive overhead in<br>compiled code then you have to change<br>the compiler but but this in particular<br>nothing happened in the compiler and<br>nothing no changes were needed there<br>um<br>it's certainly interesting to think<br>about whether we want to have an ability<br>of taking our essentially higher level<br>byte code<br>and translating that to llvm but<br>um<br>okay it's not clear that it's certainly<br>not something I'm actively working on<br>I'm not sure anybody is um it's just a<br>matter of resources I don't think we<br>have them at the moment but it is<br>something I've thought about off and on<br>but it's not active at least not on my<br>part<br>oh thank you<br>um uh thank you but<br>um<br>my question<br>um with the piping<br>you've demonstrated it to be more<br>elegant than the other method<br>however<br>um<br>I noticed a cautious approach is that<br>because of all the<br>steps that you have to go through in<br>order to get it into the base code have<br>it accepted by the compiler because I<br>look at it that with the with what you<br>presented is that it's nice to have the<br>option of how you'd like to go with your<br>code because some programmers like it<br>again there's really nothing involved in<br>the compilation no compilation issues<br>involved it's more<br>it's more a matter of the the syntax the<br>r syntax is relatively complex and<br>you've got a lot of different things<br>going on there already<br>so if you add any kind of operator<br>in<br>tax you have to fit it somewhere in the<br>uh precedence level and<br>it's it's<br>easy to<br>Miss some interactions that end up being<br>parsed differently than than you expect<br>you know any the the thing that was most<br>the biggest most was most surprising was<br>that thing that I showed with a bear<br>function on the right hand side<br>you your mind is thinking you mean it to<br>me you want it you want an Express<br>sequence of Expressions connected by<br>pipes to mean one thing<br>but that's simply not the way it's<br>parsed<br>and no compiler involved yet it's just<br>how are these sequences and symbols<br>interpreted by the parser and they just<br>nested differently than you think when<br>you're thinking types and that that's a<br>risk when you're trying to add a<br>different level of thinking about things<br>into a system that already has a lot of<br>complexity to it<br>um and so<br>pressure changes just need to be done<br>with a with a great deal of care and it<br>is again with something that's as rich<br>as this you're changing syntax and it's<br>easy to<br>to get into situations where all of a<br>sudden you can write things down that<br>you think mean one thing that they<br>actually mean something else not<br>compilation is really not an issue for<br>oh this is going in a different<br>direction but uh I do I do remember the<br>day when a lot of pure mathematicians<br>used to speak in favor of<br>um developing functions using a post-fix<br>notation rather than a prefix<br>so instead of having<br>h of G of f of x you would write that<br>down as x f g h<br>and that made it nice when you were<br>going to draw lots of arrows showing the<br>operations so I don't see us ever doing<br>this now but uh it it seems it would<br>now you do start thinking about HP<br>calculators or glaters and reverse<br>polish notation a little bit when you<br>start looking at these sorts of things<br>um<br>it's<br>okay<br>yeah there are uh you know there's some<br>folks who think that the<br>I don't know which we want to call<br>traditional the F of G of H thing or H<br>which were the H of G of X is just<br>natural and why is it a problem but<br>um<br>others really prefer to get it into the<br>order in which things happen and that<br>seems more natural<br>um<br>so<br>having removed the the dot and replaced<br>it with the underscore for the the<br>placeholder for the<br>um the input was there any consideration<br>given to to changing the the pipe<br>operator to a DOT as in a you know a<br>uh no I think the<br>so many other languages had adopted that<br>that pipe uh you know the the vertical<br>bar uh greater than sign that that it<br>seemed<br>reasonable to just stick with that that<br>is the symbol that's used by F sharp by<br>Java and and uh you know a whole bunch<br>of others<br>um it just seemed that it didn't seem<br>worth that that particular uh<br>Trend so<br>um<br>yes and some people quibble with it for<br>all sorts of reasons on some keyboards<br>it's a little harder to type than other<br>things<br>um but um<br>it didn't seem it didn't seem to make<br>sense to go against what other folks<br>have been doing<br>um Luke<br>I'm slightly more on the purest end of<br>the scale I guess<br>whenever I see a pipe written my first<br>instinct is actually to write it as a<br>series of nested function calls<br>um<br>you can<br>turn your pipe into a string and running<br>run it through the parser then that's<br>exactly what you get if you really want<br>to<br>um<br>just just one more question for me how<br>much complexity do you think can be<br>added Beyond this<br>you know I think the as you see the<br>arson tax is already getting pretty<br>complicated<br>um<br>do you see additional features getting<br>I'm not sure<br>um<br>there's certainly a number of different<br>proposals um if you go back to that that<br>uh<br>uh post by Leonel Henry that I and I<br>linked to he's got a few other things in<br>there that<br>seem not unreasonable<br>um but<br>um<br>uh<br>I'm not sure I mean they're one of the<br>various kinds of annotations and things<br>of that sort whether it's type<br>annotations or traits or properties and<br>things like that<br>have been suggested and and<br>um<br>for most of them there are alternatives<br>um you know if you come from the list<br>world where I spent many years you can<br>always think in terms of just putting in<br>a function call in the body of the<br>function that gets interpreted<br>um so uh I think there is there are<br>possibilities to adding more things but<br>I<br>I think you have to tread with caution<br>and<br>it's it's it's probably best to come up<br>with things you can do in packages first<br>and then only move to yeah we really<br>want to add new syntax we absolutely<br>have to<br>um<br>I'm not great and I don't think we have<br>anybody who really is great at writing<br>writing the the bison grammars and<br>anything we add at this point is<br>probably going to need a lot of Bison<br>programming to get in there so it better<br>be worth the trouble if you're gonna go<br>okay well if you'll join me thanking<br>Luke again for an excellent talk<br>okay so I guess we have a t-shirt drawer<br>again<br>and it is can you read it it's like uh<br>23e<br>okay excellent<br>put one in collection<br>just package it similar excellent thank<br>you<br>thanks very much see you all next week<br>hopefully</p></main><footer style="margin-top: 2rem; background: #0001; padding: 2rem; text-align: center;"><p>We Are The University</p><ul style="list-style-type: none; padding: 0; margin: 0;"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/contact">Contact</a></li></ul></footer></body></html>